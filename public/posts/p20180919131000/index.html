<!DOCTYPE html>
<html lang="en-us" dir="ltr">
<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
  



  
  


<head lang="en-us">
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
  <meta name="HandheldFriendly" content="True" />
  <meta name="MobileOptimized" content="320" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="color-scheme" content="dark light">
  <meta name="description" content="Edited by Markdown
Refered from:
John Ladd, Jessica Otis, Christopher N. Warren, and Scott Weingart, &ldquo;Exploring and Analyzing Network Data with Python,&rdquo; The Programming Historian 6 (2017), https://programminghistorian.org/en/lessons/exploring-and-analyzing-network-data-with-python.


只是一个笔记，细节要看原文。
用python探索和分析网络数据
Table of Contents

目标和要求
[数据准备 和 NetworkX 安装](#数据准备 和 NetworkX 安装)
获取数据和基本的操作
进一步分析

[添加属性](#Add attributes)


网络度量分析

The Shape of the Network

最短路径
找出最大component 并生成子图
triadic closure


Centrality

度数
特征值中心性
介数中心性




社区发现
导出数据和做结论

目标和要求
**Goals:**做完这里的步骤，你将得到如下技能：

使用Python的NetworkX 包来分析一个网络。
通过分析一个humanities network data来得到以下几点：

网络结构和path length
找到重要的或中心的节点
找到社区和subgroups


通过量化网络分析的方法，你将可以回答像这样的问题：

What is the overall structure of the network?
Who are the important people, or hubs, in the network?
What are the subgroups and communities in the network?



说明：主要是关注网络中的统计信息，而不关注可视化，其实本文是对可视化问题的补充。如果你感兴趣可视化，可先参考link" />
  <meta name="author" content="Hugo Author">
  <meta name="keywords" content="">
  <title>用python &#43; networkx探索和分析网络数据 | Combine Art and Sciences</title>
  <link rel="canonical" href="http://localhost:1313/posts/p20180919131000/" />
  

  
  <meta property="og:type" content="article" />
  <meta property="og:description" content="Edited by Markdown
Refered from:
John Ladd, Jessica Otis, Christopher N. Warren, and Scott Weingart, &ldquo;Exploring and Analyzing Network Data with Python,&rdquo; The Programming Historian 6 (2017), https://programminghistorian.org/en/lessons/exploring-and-analyzing-network-data-with-python.


只是一个笔记，细节要看原文。
用python探索和分析网络数据
Table of Contents

目标和要求
[数据准备 和 NetworkX 安装](#数据准备 和 NetworkX 安装)
获取数据和基本的操作
进一步分析

[添加属性](#Add attributes)


网络度量分析

The Shape of the Network

最短路径
找出最大component 并生成子图
triadic closure


Centrality

度数
特征值中心性
介数中心性




社区发现
导出数据和做结论

目标和要求
**Goals:**做完这里的步骤，你将得到如下技能：

使用Python的NetworkX 包来分析一个网络。
通过分析一个humanities network data来得到以下几点：

网络结构和path length
找到重要的或中心的节点
找到社区和subgroups


通过量化网络分析的方法，你将可以回答像这样的问题：

What is the overall structure of the network?
Who are the important people, or hubs, in the network?
What are the subgroups and communities in the network?



说明：主要是关注网络中的统计信息，而不关注可视化，其实本文是对可视化问题的补充。如果你感兴趣可视化，可先参考link" />
  <meta property="og:title" content="用python &#43; networkx探索和分析网络数据" />
  <meta property="og:site_name" content="Combine Art and Sciences" />
  <meta property="og:image:type" content="image/jpeg" />
  <meta property="og:url" content="http://localhost:1313/posts/p20180919131000/" />
  <meta property="og:locale" content="en-us" />

  
    <meta property="article:published_time" content="2018-09-19" />
    <meta property="article:modified_time" content="2018-09-19" />
    
  

  
  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="用python &#43; networkx探索和分析网络数据 | Combine Art and Sciences" />
  <meta name="twitter:description" content="Edited by Markdown
Refered from:
John Ladd, Jessica Otis, Christopher N. Warren, and Scott Weingart, &ldquo;Exploring and Analyzing Network Data with Python,&rdquo; The Programming Historian 6 (2017), https://programminghistorian.org/en/lessons/exploring-and-analyzing-network-data-with-python.


只是一个笔记，细节要看原文。
用python探索和分析网络数据
Table of Contents

目标和要求
[数据准备 和 NetworkX 安装](#数据准备 和 NetworkX 安装)
获取数据和基本的操作
进一步分析

[添加属性](#Add attributes)


网络度量分析

The Shape of the Network

最短路径
找出最大component 并生成子图
triadic closure


Centrality

度数
特征值中心性
介数中心性




社区发现
导出数据和做结论

目标和要求
**Goals:**做完这里的步骤，你将得到如下技能：

使用Python的NetworkX 包来分析一个网络。
通过分析一个humanities network data来得到以下几点：

网络结构和path length
找到重要的或中心的节点
找到社区和subgroups


通过量化网络分析的方法，你将可以回答像这样的问题：

What is the overall structure of the network?
Who are the important people, or hubs, in the network?
What are the subgroups and communities in the network?



说明：主要是关注网络中的统计信息，而不关注可视化，其实本文是对可视化问题的补充。如果你感兴趣可视化，可先参考link" />
  <meta name="twitter:domain" content="http://localhost:1313/posts/p20180919131000/" />

  
  
    <link rel="icon" href="http://localhost:1313/favicon.ico">
  
  
  
  

  
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/modern-normalize/modern-normalize.min.css">

  
  
  

  

  
    <link rel="stylesheet" href="http://localhost:1313/style.css" rel="preload stylesheet" as="style"/>
  

  
  
</head>

</head>
<body>
  <header>
    <header id="header">
  <div class="row">
    <div class="container has-padding nav">
      <button id="navbar-toggler" class="navbar-button" aria-hidden="true">











<svg xmlns='http://www.w3.org/2000/svg' class='ionicon' viewBox='0 0 512 512'><path d='M64 384h384v-42.67H64zm0-106.67h384v-42.66H64zM64 128v42.67h384V128z'/></svg>





</button>
      <div class="navbar-brand">
        <a class="logo navbar-button" href="http://localhost:1313/" title="Combine Art and Sciences">
          <span>Combine Art and Sciences</span>
        </a>
      </div>
      <nav class="navbar" role="navigation">
        <ul>
          
          
            <li class="nav-bar-item active">
              <a class="nav-link navbar-button" href="/posts/" title="posts">
                <span>posts</span>
              </a>
            </li>
          
            <li class="nav-bar-item">
              <a class="nav-link navbar-button" href="/tags/" title="tags">
                <span>tags</span>
              </a>
            </li>
          
            <li class="nav-bar-item">
              <a class="nav-link navbar-button" href="/archives/" title="archives">
                <span>archives</span>
              </a>
            </li>
          
            <li class="nav-bar-item">
              <a class="nav-link navbar-button" href="/about/" title="about">
                <span>about</span>
              </a>
            </li>
          
        </ul>
      </nav>
      <div class="theme-selector">
        <button class="button is-text" id="theme-selector-button" title="toggle theme">
          <span class="label icon">





<svg xmlns='http://www.w3.org/2000/svg' class='ionicon' viewBox='0 0 512 512'><path d='M256 32C132.29 32 32 132.29 32 256s100.29 224 224 224 224-100.29 224-224S379.71 32 256 32zM128.72 383.28A180 180 0 01256 76v360a178.82 178.82 0 01-127.28-52.72z'/></svg>











</span>
        </button>
      </div>
    </div>
    
      <div class="container has-padding">
        <div class="breadcrumb">
          
<ol  class="breadcrumb-nav">
  

  

  

<li >
  <a href="http://localhost:1313/">Home</a>
</li>


<li >
  <a href="http://localhost:1313/posts/">Posts</a>
</li>


<li class="active">
  <a href="http://localhost:1313/posts/p20180919131000/">用python &#43; networkx探索和分析网络数据</a>
</li>

</ol>




        </div>
      </div>
    
  </div>
</header>

  </header>
  <main>
    

<main id="main">
  <div class="container has-padding">
    <div class="article-card post single">
      <h1 class="title">用python &#43; networkx探索和分析网络数据</h1>
      <div class="post-info">
        <span>



<svg xmlns='http://www.w3.org/2000/svg' class='ionicon' viewBox='0 0 512 512'><path d='M32 456a24 24 0 0024 24h400a24 24 0 0024-24V176H32zm320-244a4 4 0 014-4h40a4 4 0 014 4v40a4 4 0 01-4 4h-40a4 4 0 01-4-4zm0 80a4 4 0 014-4h40a4 4 0 014 4v40a4 4 0 01-4 4h-40a4 4 0 01-4-4zm-80-80a4 4 0 014-4h40a4 4 0 014 4v40a4 4 0 01-4 4h-40a4 4 0 01-4-4zm0 80a4 4 0 014-4h40a4 4 0 014 4v40a4 4 0 01-4 4h-40a4 4 0 01-4-4zm0 80a4 4 0 014-4h40a4 4 0 014 4v40a4 4 0 01-4 4h-40a4 4 0 01-4-4zm-80-80a4 4 0 014-4h40a4 4 0 014 4v40a4 4 0 01-4 4h-40a4 4 0 01-4-4zm0 80a4 4 0 014-4h40a4 4 0 014 4v40a4 4 0 01-4 4h-40a4 4 0 01-4-4zm-80-80a4 4 0 014-4h40a4 4 0 014 4v40a4 4 0 01-4 4h-40a4 4 0 01-4-4zm0 80a4 4 0 014-4h40a4 4 0 014 4v40a4 4 0 01-4 4h-40a4 4 0 01-4-4zM456 64h-55.92V32h-48v32H159.92V32h-48v32H56a23.8 23.8 0 00-24 23.77V144h448V87.77A23.8 23.8 0 00456 64z'/></svg>













<time datetime=2018-09-19T13:10:00&#43;0800 class="date">September 19, 2018</time></span>
        <span>
















<svg xmlns='http://www.w3.org/2000/svg' class='ionicon' viewBox='0 0 512 512'><path d='M256 48C141.13 48 48 141.13 48 256c0 114.69 93.32 208 208 208 114.86 0 208-93.14 208-208 0-114.69-93.31-208-208-208zm108 240H244a4 4 0 01-4-4V116a4 4 0 014-4h24a4 4 0 014 4v140h92a4 4 0 014 4v24a4 4 0 01-4 4z'/></svg>
11 mins to read</span>
        
          <span>












<svg xmlns='http://www.w3.org/2000/svg' class='ionicon' viewBox='0 0 512 512'><path d='M256 256a112 112 0 10-112-112 112 112 0 00112 112zm0 32c-69.42 0-208 42.88-208 128v64h416v-64c0-85.12-138.58-128-208-128z'/></svg>




Hugo Author</span>
        
        
        
          <span>posts </span>
        
      </div>
      <article class="post-entry content">
        
          <p>Edited by Markdown</p>
<p>Refered from:
John Ladd, Jessica Otis, Christopher N. Warren, and Scott Weingart, &ldquo;Exploring and Analyzing Network Data with Python,&rdquo; The Programming Historian 6 (2017), <a href="https://programminghistorian.org/en/lessons/exploring-and-analyzing-network-data-with-python">https://programminghistorian.org/en/lessons/exploring-and-analyzing-network-data-with-python</a>.</p>
<hr>
<blockquote>
<p>只是一个笔记，细节要看原文。</p></blockquote>
<h1 id="用python探索和分析网络数据">用python探索和分析网络数据<a hidden class="heading-anchor" aria-hidden="true" href="#用python探索和分析网络数据">#</a></h1>
<h2 id="table-of-contents">Table of Contents<a hidden class="heading-anchor" aria-hidden="true" href="#table-of-contents">#</a></h2>
<ol>
<li><a href="#%E7%9B%AE%E6%A0%87%E5%92%8C%E8%A6%81%E6%B1%82">目标和要求</a></li>
<li>[数据准备 和 NetworkX 安装](#数据准备 和 NetworkX 安装)</li>
<li><a href="#%E8%8E%B7%E5%8F%96%E6%95%B0%E6%8D%AE%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%9A%84%E6%93%8D%E4%BD%9C">获取数据和基本的操作</a></li>
<li><a href="#%E8%BF%9B%E4%B8%80%E6%AD%A5%E5%88%86%E6%9E%90">进一步分析</a>
<ul>
<li>[添加属性](#Add attributes)</li>
</ul>
</li>
<li><a href="#%E7%BD%91%E7%BB%9C%E5%BA%A6%E9%87%8F%E5%88%86%E6%9E%90">网络度量分析</a>
<ul>
<li><a href="">The Shape of the Network</a>
<ul>
<li>最短路径</li>
<li>找出最大component 并生成子图</li>
<li>triadic closure</li>
</ul>
</li>
<li><a href="">Centrality</a>
<ul>
<li>度数</li>
<li>特征值中心性</li>
<li>介数中心性</li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E7%A4%BE%E5%8C%BA%E5%8F%91%E7%8E%B0">社区发现</a></li>
<li><a href="#%E5%AF%BC%E5%87%BA%E6%95%B0%E6%8D%AE%E5%92%8C%E5%81%9A%E7%BB%93%E8%AE%BA">导出数据和做结论</a></li>
</ol>
<h2 id="目标和要求">目标和要求<a hidden class="heading-anchor" aria-hidden="true" href="#目标和要求">#</a></h2>
<p>**Goals:**做完这里的步骤，你将得到如下技能：</p>
<ul>
<li>使用Python的NetworkX 包来分析一个网络。</li>
<li>通过分析一个humanities network data来得到以下几点：
<ul>
<li>网络结构和path length</li>
<li>找到重要的或中心的节点</li>
<li>找到社区和subgroups</li>
</ul>
</li>
<li>通过量化网络分析的方法，你将可以回答像这样的问题：
<ul>
<li>What is the overall structure of the network?</li>
<li>Who are the important people, or hubs, in the network?</li>
<li>What are the subgroups and communities in the network?</li>
</ul>
</li>
</ul>
<p>说明：主要是关注网络中的统计信息，而不关注可视化，其实本文是对可视化问题的补充。如果你感兴趣可视化，可先参考<a href="https://www.cnblogs.com/sonictl/p/9663650.html">link</a></p>
<p><strong>要求：</strong></p>
<ul>
<li>先看过“从诠释学到数据到网络:历史来源的数据提取和网络可视化”<a href="https://www.cnblogs.com/sonictl/p/9663650.html">link</a></li>
<li>python3 , 而不是 python2, (unix-based的操作系统，比如 OSX, 会预装python2)，有问题可以<a href="http://docs.python-guide.org/en/latest/starting/installation/">link</a></li>
<li>装了<code>pip</code> 包管理工具</li>
</ul>
<p>如果python2和python3同时装了的，那每次命令中 <code>python</code> / <code>pip</code>时，都要指明成： <code>python3</code> / <code>pip3</code>，参考：<a href="https://programminghistorian.org/lessons/introduction-and-installation">装python</a> 和 <a href="https://programminghistorian.org/lessons/installing-python-modules-pip">work with pip</a></p>
<p><strong>我们的例子：朋友社会</strong>
在Facebook上有朋友之前，有朋友协会，被称为贵格会（Quakers）。贵格会教友会于17世纪中叶在英格兰成立，是新教基督徒（Protestant Christians），他们反对英国官方教会，提倡广泛的宗教宽容，更喜欢基督徒所谓的“内在光明”和良心，而不是国家强制的正统教义。贵格会信徒的数量在17世纪中后期迅速增长，他们的成员遍布不列颠群岛、欧洲和新大陆的殖民地——尤其是宾夕法尼亚，贵格会领袖威廉·佩恩创立了贵格会，是四位作者的故乡。</p>
<p>由于学者们一直将贵格会的成长和持续时间与他们的网络的有效性联系在一起，所以本教程中使用的数据是17世纪最早的贵格会成员的名单和关系。这个数据集来源于《牛津国家传记词典》和正在进行的弗兰西斯·培根六度计划，该计划正在重建早期现代英国(1500-1700年)的社会网络。</p>
<h2 id="数据准备-和-networkx-安装">数据准备 和 NetworkX 安装<a hidden class="heading-anchor" aria-hidden="true" href="#数据准备-和-networkx-安装">#</a></h2>
<p>The file <a href="https://programminghistorian.org/assets/exploring-and-analyzing-network-data-with-python/quakers_nodelist.csv">quakers_nodelist.csv</a> is a list of early modern Quakers (nodes) and the file <a href="https://programminghistorian.org/assets/exploring-and-analyzing-network-data-with-python/quakers_edgelist.csv">quakers_edgelist.csv</a> is a list of relationships between those Quakers (edges). To download these files, simply right-click on the links and select “Save Link As…”.</p>
<p><strong>networkx</strong></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">pip3 install networkx
</span></span></code></pre></div><p><strong>modularity</strong></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">pip3 install python-louvain<span class="o">==</span>0.5
</span></span></code></pre></div><p>Recently, NetworkX updated to version 2.0. If you’re running into any problems with the code below and have worked with NetworkX before, you might try updating both the above packages with <code>pip3 install networkx --upgrade</code> and <code>pip3 install python-louvain --upgrade</code>.</p>
<p>你准备好了networkx 和 modularity package后，就可以开始写code了。
如果遇到pyCharm环境中找不到module，参考如下：</p>
<blockquote>
<p>pyCharm can manage python modules, third-party module packages easily.
Do the steps:</p>
<ul>
<li>pyCharm &raquo; Preference, search &lsquo;interpreter&rsquo;, click &ldquo;Project Interpreter&rdquo;</li>
<li>click &lsquo;+&rsquo;, enter the package name, click &lsquo;Install Package&rsquo;</li>
</ul></blockquote>
<h2 id="获取数据和基本的操作">获取数据和基本的操作<a hidden class="heading-anchor" aria-hidden="true" href="#获取数据和基本的操作">#</a></h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"></code></pre></div><p>导入我们需要的4个包，其中2个是刚刚安装的，2个是python built-in package.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl">    <span class="kn">import</span> <span class="nn">csv</span>
</span></span><span class="line"><span class="cl">    <span class="kn">from</span> <span class="nn">operator</span> <span class="kn">import</span> <span class="n">itemgetter</span>
</span></span><span class="line"><span class="cl">    <span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>
</span></span><span class="line"><span class="cl">    <span class="kn">import</span> <span class="nn">community</span> <span class="c1">#this is from python-louvain</span>
</span></span></code></pre></div><p>下一步就是<strong>从文件导入数据</strong>，通常导数据进来比较费code，比analysis还要费。打开文件，读取edge list 和 node list：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;quakers_nodelist.csv&#39;</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">nodecsv</span><span class="p">:</span> <span class="c1"># Open the file                       </span>
</span></span><span class="line"><span class="cl">    <span class="n">nodereader</span> <span class="o">=</span> <span class="n">csv</span><span class="o">.</span><span class="n">reader</span><span class="p">(</span><span class="n">nodecsv</span><span class="p">)</span> <span class="c1"># Read the csv  </span>
</span></span><span class="line"><span class="cl">    <span class="c1"># Retrieve the data (using Python list comprhension and list slicing to remove the header row, see footnote 3)</span>
</span></span><span class="line"><span class="cl">    <span class="n">nodes</span> <span class="o">=</span> <span class="p">[</span><span class="n">n</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">nodereader</span><span class="p">][</span><span class="mi">1</span><span class="p">:]</span>                     
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">node_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">n</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">]</span> <span class="c1"># Get a list of only the node names                                       </span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;quakers_edgelist.csv&#39;</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">edgecsv</span><span class="p">:</span> <span class="c1"># Open the file</span>
</span></span><span class="line"><span class="cl">    <span class="n">edgereader</span> <span class="o">=</span> <span class="n">csv</span><span class="o">.</span><span class="n">reader</span><span class="p">(</span><span class="n">edgecsv</span><span class="p">)</span> <span class="c1"># Read the csv     </span>
</span></span><span class="line"><span class="cl">    <span class="n">edges</span> <span class="o">=</span> <span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">edgereader</span><span class="p">][</span><span class="mi">1</span><span class="p">:]</span> <span class="c1"># Retrieve the data</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">node_names</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">edges</span><span class="p">))</span>
</span></span></code></pre></div><p><strong>Appendix afterwards 2019-11-12: import graph by csv file:</strong></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">edges_csv_path</span> <span class="o">=</span> <span class="s1">&#39;net_data/karate_club/graph_karate_edges_label1.csv&#39;</span>  <span class="c1"># import graph by csv file</span>
</span></span><span class="line"><span class="cl"><span class="n">net_data</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">edges_csv_path</span><span class="p">,</span> <span class="s2">&#34;r&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nb">next</span><span class="p">(</span><span class="n">net_data</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>  <span class="c1"># skip the first line in the input file</span>
</span></span><span class="line"><span class="cl"><span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">parse_edgelist</span><span class="p">(</span><span class="n">net_data</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s1">&#39;,&#39;</span><span class="p">,</span> <span class="n">create_using</span><span class="o">=</span><span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">(),</span>
</span></span><span class="line"><span class="cl">                      <span class="n">nodetype</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>  <span class="c1"># data=((&#39;weight&#39;, float),)</span>
</span></span><span class="line"><span class="cl"><span class="c1"># import matplotlib.pyplot as plt</span>
</span></span><span class="line"><span class="cl"><span class="c1"># nx.draw_networkx(G, with_labels=True)  # draw the graph, simplest way.</span>
</span></span><span class="line"><span class="cl"><span class="c1"># # nx.draw_spring(G, with_labels = True)</span>
</span></span><span class="line"><span class="cl"><span class="c1"># plt.show()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># output to csv: (write/output the graph data/edges into csv file)</span>
</span></span><span class="line"><span class="cl"><span class="n">nx</span><span class="o">.</span><span class="n">write_edgelist</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="s1">&#39;netME.csv&#39;</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s1">&#39;,&#39;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>   <span class="c1"># note data = False will not write &#39;{}&#39;</span>
</span></span></code></pre></div><h4 id="draw-graph-with-position-dictionary">draw graph with position dictionary:<a hidden class="heading-anchor" aria-hidden="true" href="#draw-graph-with-position-dictionary">#</a></h4>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">les_miserables_graph</span><span class="p">()</span>    <span class="c1"># use the les_miserables_graph()</span>
</span></span><span class="line"><span class="cl"><span class="n">pos</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">spring_layout</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mf">0.42</span><span class="p">,</span> <span class="n">iterations</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>    <span class="c1"># more: networkx.drawing.layout.*</span>
</span></span><span class="line"><span class="cl"><span class="n">nx</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">with_labels</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1"># nx.draw_spring(G, with_labels = True)  #replaced by above 2 lines</span>
</span></span><span class="line"><span class="cl"><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">G</span><span class="p">))</span>
</span></span></code></pre></div><h3 id="networkx-基础创建graph">NetworkX 基础，创建Graph<a hidden class="heading-anchor" aria-hidden="true" href="#networkx-基础创建graph">#</a></h3>
<p>Now you have your data as two Python lists: a list of nodes (<code>node_names</code>) and a list of edges (<code>edges</code>).</p>
<ol>
<li>create Graph object:</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"> <span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>  <span class="c1">#create a Graph obj G, with nothing in it.</span>
</span></span><span class="line"><span class="cl"> <span class="c1"># add lists of nodes and edges like below:</span>
</span></span><span class="line"><span class="cl"> <span class="n">G</span><span class="o">.</span><span class="n">add_nodes_from</span><span class="p">(</span><span class="n">node_names</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"> <span class="n">G</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">(</span><span class="n">edges</span><span class="p">)</span>
</span></span></code></pre></div><p>这是一种方法，更多的向Graph对象填值的方法要看<a href="https://networkx.github.io/documentation/stable/tutorial.html#adding-attributes-to-graphs-nodes-and-edges">networkX官方文档</a></p>
<p>最后，你可以用<code>info</code>函数看看你刚创建的Graph的基本情况：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">G</span><span class="p">))</span>
</span></span></code></pre></div><p>现在应该能看到这个Graph的一些基本的，表面的情况，但还远远不够。。</p>
<h4 id="邻接矩阵的生成">邻接矩阵的生成<a hidden class="heading-anchor" aria-hidden="true" href="#邻接矩阵的生成">#</a></h4>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">networkx</span> <span class="kn">import</span> <span class="n">karate_club_graph</span><span class="p">,</span> <span class="n">to_numpy_matrix</span>
</span></span><span class="line"><span class="cl"><span class="n">zkc</span> <span class="o">=</span> <span class="n">karate_club_graph</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="n">order</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">zkc</span><span class="o">.</span><span class="n">nodes</span><span class="p">()))</span>  <span class="c1"># order = [0,1,2,...]</span>
</span></span><span class="line"><span class="cl"><span class="n">A</span> <span class="o">=</span> <span class="n">to_numpy_matrix</span><span class="p">(</span><span class="n">zkc</span><span class="p">,</span> <span class="n">nodelist</span><span class="o">=</span><span class="n">order</span><span class="p">)</span>   <span class="c1"># 输入一个nx.graph, this shows how to generate its adj_Matrix</span>
</span></span><span class="line"><span class="cl"><span class="c1"># degree matrix: 度矩阵的生成</span>
</span></span><span class="line"><span class="cl"><span class="n">D</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="n">D</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matrix</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">D</span><span class="p">))</span>
</span></span></code></pre></div><h2 id="进一步分析">进一步分析<a hidden class="heading-anchor" aria-hidden="true" href="#进一步分析">#</a></h2>
<h3 id="add-attributes">Add attributes<a hidden class="heading-anchor" aria-hidden="true" href="#add-attributes">#</a></h3>
<p>光有了Nodes, &amp; edges还不够，还可以用networkx添加attributes到nodes&amp;edges.
开始创建的list，<code>nodes</code>包含了你需要的信息。NetworkX provides two convenient functions for adding attributes to all of a Graph’s nodes or edges at once: <code>nx.set_node_attributes()</code> and <code>nx.set_edge_attributes()</code>. 但使用2者之前，要求你的数据是在<em>python dictionary</em>里。意思是，name是keys；attributes是values.每个attribute都要创建一个dictionary，用花括号{}:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">hist_sig_dict</span> <span class="o">=</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl"><span class="n">gender_dict</span> <span class="o">=</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl"><span class="n">birth_dict</span> <span class="o">=</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl"><span class="n">death_dict</span> <span class="o">=</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl"><span class="n">id_dict</span> <span class="o">=</span> <span class="p">{}</span>
</span></span></code></pre></div><p>Now we can loop through our <code>nodes</code> list and add the appropriate items to each dictionary.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">:</span> <span class="c1"># Loop through the list, one row at a time</span>
</span></span><span class="line"><span class="cl">    <span class="n">hist_sig_dict</span><span class="p">[</span><span class="n">node</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">node</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">    <span class="n">gender_dict</span><span class="p">[</span><span class="n">node</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">node</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">    <span class="n">birth_dict</span><span class="p">[</span><span class="n">node</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">node</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">    <span class="n">death_dict</span><span class="p">[</span><span class="n">node</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">node</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">    <span class="n">id_dict</span><span class="p">[</span><span class="n">node</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">node</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span>
</span></span></code></pre></div><p>Now you have a set of dictionaries that you can use to add attributes to nodes in your Graph object. The <code>set_node_attributes</code> 函数有3个变量：</p>
<ul>
<li>the Graph to which you’re adding the attribute,</li>
<li>the name of the new attribute.</li>
<li>the dictionary of id-attribute pairs.</li>
</ul>
<p>The code for adding your six attributes looks like this:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">nx</span><span class="o">.</span><span class="n">set_node_attributes</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="s1">&#39;historical_significance&#39;</span><span class="p">,</span> <span class="n">hist_sig_dict</span><span class="p">)</span> <span class="c1">#新版的networkx把变量顺序换了一下，先是名，再放dict</span>
</span></span><span class="line"><span class="cl"><span class="n">nx</span><span class="o">.</span><span class="n">set_node_attributes</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="s1">&#39;gender&#39;</span><span class="p">,</span> <span class="n">gender_dict</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">nx</span><span class="o">.</span><span class="n">set_node_attributes</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="s1">&#39;birth_year&#39;</span><span class="p">,</span> <span class="n">birth_dict</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">nx</span><span class="o">.</span><span class="n">set_node_attributes</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="s1">&#39;death_year&#39;</span><span class="p">,</span> <span class="n">death_dict</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">nx</span><span class="o">.</span><span class="n">set_node_attributes</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="s1">&#39;sdfb_id&#39;</span><span class="p">,</span> <span class="n">id_dict</span><span class="p">)</span>
</span></span></code></pre></div><p>至此，每个节点都有6个属性了，you can access them at any time.例如，你可以打出所有人的生日，通过loop through them and access the <code>birth_year</code> 属性。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">():</span> <span class="c1"># Loop through every node, in our data &#34;n&#34; will be the name of the person</span>
</span></span><span class="line"><span class="cl">    <span class="nb">print</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">G</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="s1">&#39;birth_year&#39;</span><span class="p">])</span> <span class="c1"># Access every node by its name, and then by the attribute &#34;birth_year&#34;</span>
</span></span></code></pre></div><p>现在您已经学习了如何创建图形对象并向其添加属性。在下一节中，您将了解NetworkX中可用的各种指标以及如何访问它们。但是放松，您现在已经学习了本教程其余部分所需的大部分代码!</p>
<h2 id="网络度量分析">网络度量分析<a hidden class="heading-anchor" aria-hidden="true" href="#网络度量分析">#</a></h2>
<p>当您开始处理新数据集时，最好对数据有一个大致的了解。第一步，如上所述，只是打开文件，看看里面是什么。因为这是一个网络，你知道会有节点和边，但是每个有多少个呢?哪些信息附加到每个节点或边?</p>
<p>在我们的例子中，有174条边和119个节点。这些边没有方向(也就是说，人与人之间的关系是对称的)，也不包含额外的信息。对于节点，我们知道它们的名称、历史意义、性别、出生和死亡日期以及SDFB ID。这些细节告诉您可以或应该如何处理您的数据集。节点太少(比如15个)，不如用画图或阅读来分析; 太多(比如1500万)，你应该考虑从一个子集开始，或者寻找一台超级计算机。</p>
<p>网络的特性可指导您的分析。因为这个网络是无向的，所以您的分析必须使用需要节点之间对称边的度量。例如，您可以确定人们发现自己所在的社区，但是您不能确定信息可能通过哪些方向路由沿着网络流动(您需要一个定向网络来实现这一点)。在本例中，通过使用对称的、无定向关系，您将能够找到子社区和对这些社区很重要的人，对于有向网络，这个过程将更加困难(尽管仍然可能)。NetworkX允许您执行您可能设想的大多数分析，但您必须了解数据集的可承受性，并了解NetworkX算法得比其他算法更合适。</p>
<h3 id="the-shape-of-the-network">The Shape of the Network<a hidden class="heading-anchor" aria-hidden="true" href="#the-shape-of-the-network">#</a></h3>
<p>数据集看起来太抽象，要看shape of networks，还是用visualization的工具： <a href="https://gephi.org/">Gephi</a> or <a href="https://programminghistorian.org/lessons/creating-network-diagrams-from-historical-sources">Palladio</a></p>
<p><img src="https://programminghistorian.org/images/exploring-and-analyzing-network-data-with-python/exploring-and-analyzing-network-data-with-python-1.png" alt="">
Force-directed network visualization of the Quaker data, created in Gephi</p>
<p>There are lots of ways to visualize a network, and a <a href="https://en.wikipedia.org/wiki/Force-directed_graph_drawing">force-directed layout</a>, of which the above image is an example, is among the most common.</p>
<p>除了visualization，看看network density吧. <strong>density</strong>是网络中实际边与网络中所有可能边的比率。
the best way to do this is to store your metric in a variable for future reference, and print that variable.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">density</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">density</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="s2">&#34;Network density:&#34;</span><span class="p">,</span> <span class="n">density</span><span class="p">)</span>
</span></span></code></pre></div><h4 id="最短路径">最短路径<a hidden class="heading-anchor" aria-hidden="true" href="#最短路径">#</a></h4>
<p>看名字就知道啥意思：A shortest path measurement calculates the shortest possible series of nodes and edges that stand between any two nodes. The Six Degrees of Kevin Bacon game, from which <a href="http://sixdegreesoffrancisbacon.com/">our project</a> takes its name, is basically a game of finding shortest paths (with a path length of six or less) from Kevin Bacon to any other actor.</p>
<p>Let’s find the shortest path between Margaret Fell and George Whitehead:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">fell_whitehead_path</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">shortest_path</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="s2">&#34;Margaret Fell&#34;</span><span class="p">,</span> <span class="n">target</span><span class="o">=</span><span class="s2">&#34;George Whitehead&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="s2">&#34;Shortest path between Fell and Whitehead:&#34;</span><span class="p">,</span> <span class="n">fell_whitehead_path</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="s2">&#34;Length of that path:&#34;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">fell_whitehead_path</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="c1">#length of path</span>
</span></span></code></pre></div><p>这个执行比较费时，因为先要找出所有，在选出最短的。
python还有一些玩shortest path 的工具，如最短路径、全局最短路径、是否存在路径等。请看文档：<a href="https://networkx.github.io/documentation/stable/reference/algorithms/shortest_paths.html">link</a>
<code>diameter</code>: 图中最长的最短路径。用<code>nx.diameter(G)</code>，在Quaker网络里会报错，因为有孤立的边。</p>
<h4 id="找出最大component并生成子图">找出最大component并生成子图<a hidden class="heading-anchor" aria-hidden="true" href="#找出最大component并生成子图">#</a></h4>
<p>You can remedy this by first finding out if your Graph “is connected” (i.e. all one component) and, if not connected, finding the largest component and calculating diameter on that component alone. Here’s the code:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="c1"># If your Graph has more than one component, this will return False:</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">is_connected</span><span class="p">(</span><span class="n">G</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># Next, use nx.connected_components to get the list of components,</span>
</span></span><span class="line"><span class="cl"><span class="c1"># then use the max() command to find the largest one:</span>
</span></span><span class="line"><span class="cl"><span class="n">components</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">connected_components</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="s1">&#39;num of connected_components:&#39;</span><span class="p">,</span> <span class="n">nx</span><span class="o">.</span><span class="n">number_connected_components</span><span class="p">(</span><span class="n">G</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"><span class="n">largest_component</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">components</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="nb">len</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># Create a &#34;subgraph&#34; of just the largest component</span>
</span></span><span class="line"><span class="cl"><span class="c1"># Then calculate the diameter of the subgraph, just like you did with density.</span>
</span></span><span class="line"><span class="cl"><span class="c1">#</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">subgraph</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">subgraph</span><span class="p">(</span><span class="n">largest_component</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">diameter</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">diameter</span><span class="p">(</span><span class="n">subgraph</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="s2">&#34;Network diameter of largest component:&#34;</span><span class="p">,</span> <span class="n">diameter</span><span class="p">)</span>
</span></span></code></pre></div><h4 id="traverse-all-connected-components">Traverse all connected components:<a hidden class="heading-anchor" aria-hidden="true" href="#traverse-all-connected-components">#</a></h4>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="c1"># Traverse all connected components:</span>
</span></span><span class="line"><span class="cl"><span class="c1"># gen the list of components </span>
</span></span><span class="line"><span class="cl"><span class="n">compnt_list</span> <span class="o">=</span> <span class="p">[]</span>       <span class="c1"># list of component, each component is a set</span>
</span></span><span class="line"><span class="cl"><span class="n">list_componet_size</span> <span class="o">=</span> <span class="p">[]</span>   <span class="c1"># list of size of each component, list of numbers</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="n">compnt_i</span> <span class="ow">in</span> <span class="n">nx</span><span class="o">.</span><span class="n">connected_components</span><span class="p">(</span><span class="n">G</span><span class="p">):</span>  <span class="c1"># type(compnet_i) = set</span>
</span></span><span class="line"><span class="cl">    <span class="n">compnt_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">compnt_i</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">list_componet_size</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">compnt_i</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">    <span class="nb">print</span><span class="p">(</span><span class="n">compnt_i</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">compnt_list</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="nb">len</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">list_componet_size</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="s1">&#39;list of size of componet (sorted):&#39;</span><span class="p">,</span> <span class="n">list_componet_size</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">subgraph</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">subgraph</span><span class="p">(</span><span class="n">compnt_list</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="c1"># create subgraph using the 3-th largest component </span>
</span></span></code></pre></div><h4 id="triadic-closure">triadic closure<a hidden class="heading-anchor" aria-hidden="true" href="#triadic-closure">#</a></h4>
<p><strong>Triadic closure</strong> 是指如果2人正好认识同1个人，那么这2个人倾向于互相认识。这回造成三角形的闭环，completing a triangle in the visualization of three edges connecting Fox, Fell, and Whitehead. The number of these enclosed triangles in the network can be used to find clusters and communities of individuals that all know each other fairly well.</p>
<p>计算triadic closure的方法叫<strong>clustering coefficient</strong>，because of this clustering tendency. 但在这里要用的概念叫<code>Transitivity</code>. Transitivity is the ratio of <em>all triangles</em> over all <em>possible triangles</em>.</p>
<p>You can calculate transitivity in one line, the same way you calculated density:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">triadic_closure</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">transitivity</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="s2">&#34;Triadic closure:&#34;</span><span class="p">,</span> <span class="n">triadic_closure</span><span class="p">)</span>
</span></span></code></pre></div><p>Quaker网络中的transitivity = 0.1694左右，比density 0.0248 大，说明图不稠密，还有一些possible triangles to begin with. 也说明，那些有更高度数的nodes更倾向于存在在三角形中。也就是说，已经有很多连接的节点很可能是这些封闭三角形的一部分。为了支持这一点，您需要更多地注意具有高度数的节点。
a good next step is to find which nodes are the most important ones in your network.</p>
<h3 id="centrality">Centrality<a hidden class="heading-anchor" aria-hidden="true" href="#centrality">#</a></h3>
<p>Which nodes are the most important?” there are many different ways of calculating centrality. Here you’ll learn about three of the most common centrality measures: <strong>degree</strong>, <strong>betweenness centrality</strong>, and <strong>eigenvector centrality</strong>.</p>
<p><strong>度数degree</strong></p>
<ul>
<li>最简单直接常用的一个统计量，就是一个节点身上的边的数量。
先创建一个包含degree的dictionary，作为attribute 添加到每个节点中。The keys are nodes and the values are centrality measures.</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">degree_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">degree</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">()))</span>
</span></span><span class="line"><span class="cl"><span class="n">nx</span><span class="o">.</span><span class="n">set_node_attributes</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="s1">&#39;degree&#39;</span><span class="p">,</span> <span class="n">degree_dict</span><span class="p">)</span> <span class="c1">#注意参数顺序</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="s1">&#39;William Penn&#39;</span><span class="p">])</span> <span class="c1">#see William Penn’s degree along with his other information </span>
</span></span></code></pre></div><p>在你网络的所有节点<code>G.nodes()</code>的列表上，使用<code>G.degree()</code>方法。可看到console输出：</p>
<pre tabindex="0"><code>{&#39;historical_significance&#39;: &#39;Quaker leader and founder of Pennsylvania&#39;, &#39;gender&#39;: &#39;male&#39;, &#39;birth_year&#39;: &#39;1644&#39;, &#39;death_year&#39;: &#39;1718&#39;, &#39;sdfb_id&#39;: &#39;10009531&#39;, &#39;degree&#39;: 18}
</code></pre><p>如果你想画出 degree 的分布直方图，参考：<a href="https://www.cnblogs.com/sonictl/p/11647416.html">draw histogram</a></p>
<p>在python可以任意sort一些值: 比如使用内建的<code>sourted()</code>函数来sort一个dictionary by its keys or values. 并找到top 20的nodes ranked by degree. 你需要用<code>itemgetter()</code>来帮你搞定。如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">sorted_degree</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">degree_dict</span><span class="o">.</span><span class="n">items</span><span class="p">(),</span> <span class="n">key</span><span class="o">=</span><span class="n">itemgetter</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</span></span></code></pre></div><p>看<code>sorted()</code>的三个参数：</p>
<ul>
<li>第一个是 the dictionary you want to sort;</li>
<li>第二个是 what to sort by，在这里1是指第2个值，或者是the value of your dictionary;</li>
<li>第三个是 要不要Reverse. True -&gt; Highest be the first.降序</li>
</ul>
<p>建立了sorted list, 就可以loop through it, and use list slicing to get only the top 20 nodes:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="s2">&#34;Top 20 nodes by degree&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">sorted_degree</span><span class="p">[:</span><span class="mi">20</span><span class="p">]:</span>
</span></span><span class="line"><span class="cl">    <span class="nb">print</span> <span class="n">d</span>
</span></span></code></pre></div><p>其实你看到的度数高的人，那些hub，如William Penn, 他是 Quaker leader 确实很重要，但多数social networks have just few hubs, 剩下的不那么高的又怎样呢？ 很多时候那些高度数的节点带来的信息并不令人惊奇，比如 Penn or Quakerism co-founder Margaret Fell, with a degree of 13. 你会发现高度数的人基本上就是那些founder.</p>
<p><strong>特征向量中心性</strong>
<a href="https://networkx.github.io/documentation/stable/reference/algorithms/generated/networkx.algorithms.centrality.eigenvector_centrality.html">Eigenvector centrality</a> is a kind of extension of degree - 它考虑了本身的度数和它邻居的度数（但不是简单的比例关系，要用$Ax = \lambda x$算）。Eigenvector centrality cares if you are a hub, but it also cares how many hubs you are connected to. 对于了解哪些节点可以快速获取其他节点的信息，Eigenvector centrality就有用了。它被计算为从0到1的值：越接近1，中间度越大。如果你认识很多有关系的人，你可以很有效地传播信息。</p>
<p><strong>介数中心性</strong>
<a href="https://networkx.github.io/documentation/stable/reference/algorithms/generated/networkx.algorithms.centrality.betweenness_centrality.html">Betweenness centrality</a> is a bit different. <strong>介数中心性</strong> doesn’t care about the number of edges any one node. 介数中心性考虑的是所有的<strong>shortest paths that pass through a particular node</strong>. To do this, it must first calculate every possible shortest path in your network, so keep in mind that betweenness centrality will take longer to calculate than other centrality measures. 介数中心性(也以0到1的尺度表示)在查找<strong>连接网络中两个不同部分的节点</strong>方面相当出色。如果您是连接两个集群的唯一对象，那么这些集群之间的所有通信都必须经过您。与hub不同，这种节点通常称为<strong>broker</strong>代理。这个指标不是找到brokerage的唯一方法，还有别的系统化的方法。但它很简单，不是因为它占有边数多，而是它提供了一个不同groups之间的桥梁，cohesion.</p>
<p>These two centrality measures are even simpler to run than degree—they don’t need to be fed a list of nodes, just the graph <code>G</code>. You can run them with these functions:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">eigenvector_dict</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">eigenvector_centrality</span><span class="p">(</span><span class="n">G</span><span class="p">)</span> <span class="c1"># Run eigenvector centrality</span>
</span></span><span class="line"><span class="cl"><span class="n">betweenness_dict</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">betweenness_centrality</span><span class="p">(</span><span class="n">G</span><span class="p">)</span> <span class="c1"># Run betweenness centrality</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># Assign each to an attribute in your network</span>
</span></span><span class="line"><span class="cl"><span class="n">nx</span><span class="o">.</span><span class="n">set_node_attributes</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="s1">&#39;betweenness&#39;</span><span class="p">,</span> <span class="n">betweenness_dict</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">nx</span><span class="o">.</span><span class="n">set_node_attributes</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="s1">&#39;eigenvector&#39;</span><span class="p">,</span> <span class="n">eigenvector_dict</span><span class="p">)</span>
</span></span></code></pre></div><p>同样可以sort 这些量：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">sorted_betweenness</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">betweenness_dict</span><span class="o">.</span><span class="n">items</span><span class="p">(),</span> <span class="n">key</span><span class="o">=</span><span class="n">itemgetter</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="s2">&#34;Top 20 nodes by betweenness centrality:&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">sorted_betweenness</span><span class="p">[:</span><span class="mi">20</span><span class="p">]:</span>
</span></span><span class="line"><span class="cl">    <span class="nb">print</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
</span></span></code></pre></div><p>你可以看到，有高度数的节点通常有高介数中心性，但看看Elizabeth Leavens 和 Mary Penington， 她们的度数分别为：2 &amp; 4, 在top20之外。 介数中心性分别为：0.027(17th) &amp; 0.024(20th)。在Python中进行这些计算的优点是可以快速比较两组计算。如果你想知道介数中心性高的节点中哪个节点度低呢?也就是说:哪些高介数中心性节点是意料之外的?您可以使用以上排序列表的组合:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="c1">#First get the top 20 nodes by betweenness as a list</span>
</span></span><span class="line"><span class="cl"><span class="n">top_betweenness</span> <span class="o">=</span> <span class="n">sorted_betweenness</span><span class="p">[:</span><span class="mi">20</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">#Then find and print their degree</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="n">tb</span> <span class="ow">in</span> <span class="n">top_betweenness</span><span class="p">:</span> <span class="c1"># Loop through top_betweenness</span>
</span></span><span class="line"><span class="cl">    <span class="n">degree</span> <span class="o">=</span> <span class="n">degree_dict</span><span class="p">[</span><span class="n">tb</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="c1"># Use degree_dict to access a node&#39;s degree, see footnote 2</span>
</span></span><span class="line"><span class="cl">    <span class="nb">print</span><span class="p">(</span><span class="s2">&#34;Name:&#34;</span><span class="p">,</span> <span class="n">tb</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s2">&#34;| Betweenness Centrality:&#34;</span><span class="p">,</span> <span class="n">tb</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s2">&#34;| Degree:&#34;</span><span class="p">,</span> <span class="n">degree</span><span class="p">)</span>
</span></span></code></pre></div><p>从这些结果可以证实，有些人，比如Leavens和Penington，中间度高，度低。这可能意味着，这些女性是重要的经纪人，将原本不同的部分联系在一起。你还可以了解到你已经认识的人的一些意想不到的事情——在这个列表中，你可以看到佩恩的degree比贵格会创始人乔治·福克斯低，但中间度更高。也就是说，仅仅认识更多的人并不够。</p>
<p>这只触及了在Python中使用网络度量可以做的事情的表面。NetworkX提供了许多函数和度量，供您以各种组合方式使用，您可以使用Python以几乎无限的方式扩展这些度量。像Python编程语言或者R将给你灵活地探索你的网络计算方式，其他接口不能，通过允许你结合和比较你的网络与其他属性的统计结果数据(如日期和职业，一开始本教程时你就添加到网络了!)。</p>
<h2 id="社区发现">社区发现<a hidden class="heading-anchor" aria-hidden="true" href="#社区发现">#</a></h2>
<p>Advanced NetworkX: Community detection with modularity
关于网络数据集的另一个常见问题是，在更大的社会结构中，子组或社区是什么。你的社交网络是一个人人都认识的快乐大家庭吗?或者，它是一组较小的子组，仅由一两个中介连接? 有好多方法，但比较常见的是用modularity来做社区发现。Modularity is a measure of relative density in your network: a community (called a <strong>module</strong> or modularity <strong>class</strong>) has high density relative to other nodes within its module but low density with those outside.</p>
<p>Modularity gives you an overall score of how fractious your network is, and that score can be used to <strong>partition</strong> the network and return the individual communities.</p>
<p>Though we won’t cover it in this tutorial, it’s usually a good idea to get the global modularity score first to determine whether you’ll learn anything by partitioning your network according to modularity. To see the overall modularity score, take the communities you calculated with <code>communities = community.best_partition(G)</code> and run <code>global_modularity = community.modularity(communities, G)</code>. Then just <code>print(global_modularity)</code>.</p>
<p>Community detection and partitioning in NetworkX requires a little more setup than some of the other metrics. There are some built-in approaches to community detection (like <a href="https://networkx.github.io/documentation/stable/reference/algorithms/generated/networkx.algorithms.flow.minimum_cut.html">minimum cut</a>, but modularity is not included with NetworkX. Fortunately there’s an <a href="https://github.com/taynaud/python-louvain/">additional python module</a> you can use with NetworkX, which you already installed and imported at the beginning of this tutorial. You can read the <a href="http://perso.crans.org/aynaud/communities/api.html">full documentation</a> for all of the functions the <strong>community</strong> module offers, but for most community detection purposes you’ll only want <code>best_partition()</code>:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">communities</span> <span class="o">=</span> <span class="n">community</span><span class="o">.</span><span class="n">best_partition</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
</span></span></code></pre></div><p>上面代码会创建一个字典，<code>best_partition()</code>要看适合这个graph的最合理的# of communities. 并给每个node assign一个编号，从0开始。就是每个node belong to 的编号。你可以add these values to nodes in the same way:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">nx</span><span class="o">.</span><span class="n">set_node_attributes</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="s1">&#39;modularity&#39;</span><span class="p">,</span><span class="n">communities</span><span class="p">)</span>
</span></span></code></pre></div><p>你可以把他们结合起来，比如你找找在modularity 0中，最大的eigenvector centrality是哪个Node:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="c1"># First get a list of just the nodes in that class</span>
</span></span><span class="line"><span class="cl"><span class="n">class0</span> <span class="o">=</span> <span class="p">[</span><span class="n">n</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">()</span> <span class="k">if</span> <span class="n">G</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="s1">&#39;modularity&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># Then create a dictionary of the eigenvector centralities of those nodes</span>
</span></span><span class="line"><span class="cl"><span class="n">class0_eigenvector</span> <span class="o">=</span> <span class="p">{</span><span class="n">n</span><span class="p">:</span><span class="n">G</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="s1">&#39;eigenvector&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">class0</span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># Then sort that dictionary and print the first 5 results</span>
</span></span><span class="line"><span class="cl"><span class="n">class0_sorted_by_eigenvector</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">class0_eigenvector</span><span class="o">.</span><span class="n">items</span><span class="p">(),</span> <span class="n">key</span><span class="o">=</span><span class="n">itemgetter</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="s2">&#34;Modularity Class 0 Sorted by Eigenvector Centrality:&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">class0_sorted_by_eigenvector</span><span class="p">[:</span><span class="mi">5</span><span class="p">]:</span>
</span></span><span class="line"><span class="cl">    <span class="nb">print</span><span class="p">(</span><span class="s2">&#34;Name:&#34;</span><span class="p">,</span> <span class="n">node</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s2">&#34;| Eigenvector Centrality:&#34;</span><span class="p">,</span> <span class="n">node</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
</span></span></code></pre></div><p>使用特征向量中心性作为排序，可以让您了解这个模块化类中的重要人物。你会注意到，前五名中的大多数人，尤其是William Penn, William Bradford (<em>not</em> the Plymouth founder), and James Logan,都在美国呆了很长时间。Bradford and Tace Sowle都是著名的贵格会印刷商。只要稍加挖掘，我们就会发现，这群人属于一起，既有地理上的原因，也有职业上的原因。这表明模块化可能正在按照预期工作。<em>我想说的是，对于数据的背景理解很重要。</em></p>
<p>在像这样的小型网络中，一个常见的任务是查找并列出所有模块化类及其成员。在较大的网络中，列表可能长得难以阅读，可以通过可视化网络并根据节点的模块类为其添加颜色。You can do this by manipulating the <code>communities</code> dictionary. You’ll need to reverse the <em>keys</em> and <em>values</em> of this dictionary so that the keys are the modularity class numbers and the values are lists of names. You can do so like this把这个dictionary的keys 和 values对调过来:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">modularity</span> <span class="o">=</span> <span class="p">{}</span> <span class="c1"># Create a new, empty dictionary</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">communities</span><span class="o">.</span><span class="n">items</span><span class="p">():</span> <span class="c1"># Loop through the community dictionary</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="n">v</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">modularity</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">modularity</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="c1"># Add a new key for a modularity class the code hasn&#39;t seen before</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">modularity</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="c1"># Append a name to the list for a modularity class the code has already seen</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">modularity</span><span class="o">.</span><span class="n">items</span><span class="p">():</span> <span class="c1"># Loop through the new dictionary</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span> <span class="c1"># Filter out modularity classes with 2 or fewer nodes</span>
</span></span><span class="line"><span class="cl">        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Class &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">k</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;:&#39;</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="c1"># Print out the classes and their members</span>
</span></span></code></pre></div><p>In the line <code>if len(v) &gt; 2</code>,我们把包含少于2个节点的modularity滤除了。</p>
<p>单独使用NetworkX将使您走得更远，您可以通过直接使用数据找到关于模块化类的许多信息。但是，您几乎总是希望可视化数据(也许还希望将模块化表示为节点颜色)。在下一节中，您将了解如何导出NetworkX数据以供其他程序使用。</p>
<h2 id="导出数据和做结论">导出数据和做结论<a hidden class="heading-anchor" aria-hidden="true" href="#导出数据和做结论">#</a></h2>
<h3 id="导出数据">导出数据<a hidden class="heading-anchor" aria-hidden="true" href="#导出数据">#</a></h3>
<p>NetworkX 支持各种数据格式的导出 for <a href="https://networkx.github.io/documentation/stable/reference/readwrite/index.html">data export</a>. If you wanted to export a plaintext edgelist to load into Palladio, there’s a <a href="https://networkx.github.io/documentation/stable/reference/readwrite/generated/networkx.readwrite.edgelist.write_edgelist.html">convenient wrapper</a> for that. Frequently at <em>Six Degrees of Francis Bacon</em>, we export NetworkX data in <a href="https://networkx.github.io/documentation/stable/reference/readwrite/generated/networkx.readwrite.json_graph.node_link_data.html">D3’s specialized JSON format</a>, for visualization in the browser. 如果你有更高级的统计操作，你可以 <a href="https://networkx.github.io/documentation/stable/reference/generated/networkx.convert_matrix.to_pandas_adjacency.html">export</a> your graph as a <a href="http://pandas.pydata.org/">Pandas dataframe</a> . 有很多选项，如果您一直在努力将所有matrics作为属性添加到图形对象中，那么您的所有数据将一次性导出。</p>
<p>多数格式的导出方法都一样，这里我们 export data into Gephi’s GEXF format. 用它，你可以 upload it <a href="https://gephi.org/users/supported-graph-formats/">directly into Gephi</a> for visualization.通常一句代码就搞定，用 <code>quaker_network.gexf</code>. To export type:</p>
<pre tabindex="0"><code>nx.write_gexf(G, &#39;quaker_network.gexf&#39;)
</code></pre><p>That’s it! When you run your Python script, it will automatically place the new GEXF file in the same directory as your Python file. 每一种可以导出的格式就是可以导入的。 If you have a GEXF file from Gephi that you want to put into NetworkX, you’d type <code>G = nx.read_gexf('some_file.gexf')</code>.</p>
<h3 id="结论draw-conclusions">结论Draw conclusions<a hidden class="heading-anchor" aria-hidden="true" href="#结论draw-conclusions">#</a></h3>
<p>在用Python处理和审查了一系列网络指标之后，您现在有了关于这个早期现代英国教友派信徒网络的争论和结论的证据。例如，您知道网络的密度相对较低，这意味着松散的关联和/或不完整的原始数据。你知道，这个社区是围绕着几个不成比例的大中心hubs组织起来的，其中包括玛格丽特·费尔(Margaret Fell)和乔治·福克斯(George Fox)等教派的创始人，以及威廉·佩恩(William Penn)等重要的政治和宗教领袖。更有帮助的是，你知道一些学历相对较低的女性，比如伊丽莎白•里维斯(Elizabeth Leavens)和玛丽•佩宁顿(Mary Penington)，她们(由于中间度较高)可能充当了中间人brokers，将多个群体联系起来。最后，您了解到网络是由一个大组件components和许多非常小的组件组成的。在这个最大的组成部分中，有几个截然不同的社区communities，其中一些似乎是围绕时间或地点组织起来的(比如佩恩和他的美国同事)。由于您将元数据添加到网络中，因此您可以使用工具进一步研究这些指标，并可能解释您确定的一些结构特性。</p>
<p>每一个发现都是对更多研究的邀请，而不是终点或证据。网络分析是一组关于数据集中关系结构的有针对性问题的工具，NetworkX为许多常用技术和指标提供了一个相对简单的接口。通过提供关于社区结构的信息，网络是将研究扩展到小组的一种有用方式，我们希望您能从本教程中得到启发，使用这些指标来丰富您自己的研究，并探索网络分析的灵活性，而不仅仅是可视化。</p>
<blockquote>
<p>这篇tutorial，作者相当的用心啊。全篇浑然一体，简直是教材级的干货~ 入门用，难得的好~精品！</p></blockquote>



        
      </article>
    </div>

    
      <div class="meta article-card">
    <div class="row">
      <span class="label">



<svg xmlns='http://www.w3.org/2000/svg' class='ionicon' viewBox='0 0 512 512'><path d='M32 456a24 24 0 0024 24h400a24 24 0 0024-24V176H32zm320-244a4 4 0 014-4h40a4 4 0 014 4v40a4 4 0 01-4 4h-40a4 4 0 01-4-4zm0 80a4 4 0 014-4h40a4 4 0 014 4v40a4 4 0 01-4 4h-40a4 4 0 01-4-4zm-80-80a4 4 0 014-4h40a4 4 0 014 4v40a4 4 0 01-4 4h-40a4 4 0 01-4-4zm0 80a4 4 0 014-4h40a4 4 0 014 4v40a4 4 0 01-4 4h-40a4 4 0 01-4-4zm0 80a4 4 0 014-4h40a4 4 0 014 4v40a4 4 0 01-4 4h-40a4 4 0 01-4-4zm-80-80a4 4 0 014-4h40a4 4 0 014 4v40a4 4 0 01-4 4h-40a4 4 0 01-4-4zm0 80a4 4 0 014-4h40a4 4 0 014 4v40a4 4 0 01-4 4h-40a4 4 0 01-4-4zm-80-80a4 4 0 014-4h40a4 4 0 014 4v40a4 4 0 01-4 4h-40a4 4 0 01-4-4zm0 80a4 4 0 014-4h40a4 4 0 014 4v40a4 4 0 01-4 4h-40a4 4 0 01-4-4zM456 64h-55.92V32h-48v32H159.92V32h-48v32H56a23.8 23.8 0 00-24 23.77V144h448V87.77A23.8 23.8 0 00456 64z'/></svg>













Published At</span><time>2018-09-19 13:10 CST</time>
      
    </div>

    

    
      <div class="row social-share">
        <span class="label">















<svg xmlns='http://www.w3.org/2000/svg' class='ionicon' viewBox='0 0 512 512'><path d='M272 176v161h-32V176H92a12 12 0 00-12 12v280a12 12 0 0012 12h328a12 12 0 0012-12V188a12 12 0 00-12-12zM272 92.63l64 64L358.63 134 256 31.37 153.37 134 176 156.63l64-64V176h32V92.63z'/></svg>

Share with</span>
        
        
        <a
          target="_blank"
          title="share to reddit"
          rel="noopener noreferrer"
          aria-label="share 用python &#43; networkx探索和分析网络数据 on reddit"
          href="https://reddit.com/submit?url=http%3a%2f%2flocalhost%3a1313%2fposts%2fp20180919131000%2f&title=%e7%94%a8python%20%2b%20networkx%e6%8e%a2%e7%b4%a2%e5%92%8c%e5%88%86%e6%9e%90%e7%bd%91%e7%bb%9c%e6%95%b0%e6%8d%ae">
          









<svg xmlns='http://www.w3.org/2000/svg' class='ionicon' viewBox='0 0 512 512' fill="currentColor" stroke="currentColor" stroke-width="10"><path d='M324 256a36 36 0 1036 36 36 36 0 00-36-36z'/><circle cx='188' cy='292' r='36' transform='rotate(-22.5 187.997 291.992)'/><path d='M496 253.77c0-31.19-25.14-56.56-56-56.56a55.72 55.72 0 00-35.61 12.86c-35-23.77-80.78-38.32-129.65-41.27l22-79 66.41 13.2c1.9 26.48 24 47.49 50.65 47.49 28 0 50.78-23 50.78-51.21S441 48 413 48c-19.53 0-36.31 11.19-44.85 28.77l-90-17.89-31.1 109.52-4.63.13c-50.63 2.21-98.34 16.93-134.77 41.53A55.38 55.38 0 0072 197.21c-30.89 0-56 25.37-56 56.56a56.43 56.43 0 0028.11 49.06 98.65 98.65 0 00-.89 13.34c.11 39.74 22.49 77 63 105C146.36 448.77 199.51 464 256 464s109.76-15.23 149.83-42.89c40.53-28 62.85-65.27 62.85-105.06a109.32 109.32 0 00-.84-13.3A56.32 56.32 0 00496 253.77zM414 75a24 24 0 11-24 24 24 24 0 0124-24zM42.72 253.77a29.6 29.6 0 0129.42-29.71 29 29 0 0113.62 3.43c-15.5 14.41-26.93 30.41-34.07 47.68a30.23 30.23 0 01-8.97-21.4zM390.82 399c-35.74 24.59-83.6 38.14-134.77 38.14S157 423.61 121.29 399c-33-22.79-51.24-52.26-51.24-83A78.5 78.5 0 0175 288.72c5.68-15.74 16.16-30.48 31.15-43.79a155.17 155.17 0 0114.76-11.53l.3-.21.24-.17c35.72-24.52 83.52-38 134.61-38s98.9 13.51 134.62 38l.23.17.34.25A156.57 156.57 0 01406 244.92c15 13.32 25.48 28.05 31.16 43.81a85.44 85.44 0 014.31 17.67 77.29 77.29 0 01.6 9.65c-.01 30.72-18.21 60.19-51.25 82.95zm69.6-123.92c-7.13-17.28-18.56-33.29-34.07-47.72A29.09 29.09 0 01440 224a29.59 29.59 0 0129.41 29.71 30.07 30.07 0 01-8.99 21.39z'/><path d='M323.23 362.22c-.25.25-25.56 26.07-67.15 26.27-42-.2-66.28-25.23-67.31-26.27a4.14 4.14 0 00-5.83 0l-13.7 13.47a4.15 4.15 0 000 5.89c3.4 3.4 34.7 34.23 86.78 34.45 51.94-.22 83.38-31.05 86.78-34.45a4.16 4.16 0 000-5.9l-13.71-13.47a4.13 4.13 0 00-5.81 0z'/></svg>








        </a>
        <a
          target="_blank"
          title="share to twitter"
          rel="noopener noreferrer"
          aria-label="share 用python &#43; networkx探索和分析网络数据 on twitter"
          href="https://twitter.com/intent/tweet/?text=%e7%94%a8python%20%2b%20networkx%e6%8e%a2%e7%b4%a2%e5%92%8c%e5%88%86%e6%9e%90%e7%bd%91%e7%bb%9c%e6%95%b0%e6%8d%ae&amp;url=http%3a%2f%2flocalhost%3a1313%2fposts%2fp20180919131000%2f&amp;hashtags=">
          










<svg class="ionicon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" style="fill:none;" stroke="currentColor" stroke-width="2"><path d="M23 3a10.9 10.9 0 0 1-3.14 1.53 4.48 4.48 0 0 0-7.86 3v1A10.66 10.66 0 0 1 3 4s-4 9 5 13a11.64 11.64 0 0 1-7 2c9 5 20 0 20-11.5a4.5 4.5 0 0 0-.08-.83A7.72 7.72 0 0 0 23 3z"></path></svg>







        </a>
        <a
          target="_blank"
          title="share to facebook"
          rel="noopener noreferrer"
          aria-label="share 用python &#43; networkx探索和分析网络数据 on facebook"
          href="https://facebook.com/sharer/sharer.php?u=http%3a%2f%2flocalhost%3a1313%2fposts%2fp20180919131000%2f">
          








<svg xmlns="http://www.w3.org/2000/svg" class="ionicon" viewBox="0 0 24 24" style="fill:none;" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-facebook"><path d="M18 2h-3a5 5 0 0 0-5 5v3H7v4h3v8h4v-8h3l1-4h-4V7a1 1 0 0 1 1-1h3z"></path></svg>









        </a>
      </div>
    

    
</div>

    

    

  </div>
</main>

  </main>
  <footer>
    <footer id="footer">
  <div class="container has-padding is-flex">
    <ul class="links">
      
      <li>
        </li>
      <li>
        <a
          rel="nofollow"
          target="_blank"
          href="https://github.com/wayjam/hugo-theme-fluency"
          title="using Hugo theme fluency">
          Theme Fluency
        </a>
      </li>
      <li>
        <a rel="nofollow" target="_blank" href="https://gohugo.io" title="Built with hugo">Built with Hugo</a>
      </li>
    </ul>
    <div class="copyright">
       &copy; 2025 Combine Art and Sciences
      
    </div>
  </div>
</footer>

<script>
    window.FluencyCopyIcon = '\n\n\n\n\n\n\n\u003csvg xmlns=\u0027http:\/\/www.w3.org\/2000\/svg\u0027 class=\u0027ionicon\u0027 viewBox=\u00270 0 512 512\u0027\u003e\u003crect x=\u0027128\u0027 y=\u0027128\u0027 width=\u0027336\u0027 height=\u0027336\u0027 rx=\u002757\u0027 ry=\u002757\u0027 stroke-linejoin=\u0027round\u0027 class=\u0027ionicon-fill-none ionicon-stroke-width\u0027\/\u003e\u003cpath d=\u0027M383.5 128l.5-24a56.16 56.16 0 00-56-56H112a64.19 64.19 0 00-64 64v216a56.16 56.16 0 0056 56h24\u0027 stroke-linecap=\u0027round\u0027 stroke-linejoin=\u0027round\u0027 class=\u0027ionicon-fill-none ionicon-stroke-width\u0027\/\u003e\u003c\/svg\u003e\n\n\n\n\n\n\n\n\n\n\n'
</script>


<script defer src="http://localhost:1313/js/main.min.15ea6de828b83519cdc1bc66872563a50cd5e59b4b1cfc6f31019951922b2e78.js" integrity="sha256-Fept6Ci4NRnNwbxmhyVjpQzV5ZtLHPxvMQGZUZIrLng=" crossorigin="anonymous" async></script>


    <link
  rel="stylesheet"
  href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css"
  integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X"
  crossorigin="anonymous"
/>


<script
  defer
  src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js"
  integrity="sha384-g7c+Jr9ZivxKLnZTDUhnkOnsh30B4H0rpLUpJ4jAIKs4fnJI+sEnkvrMWph2EDg4"
  crossorigin="anonymous"
></script>


<script
  defer
  src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js"
  integrity="sha384-mll67QQFJfxn0IYznZYonOWZ644AWYC+Pt2cHqMaRhXVrursRwvLnLaebdGIlYNa"
  crossorigin="anonymous"
  onload="renderMathInElement(document.body);"
></script>



<noscript>
<style type=text/css>#theme-selector-button{display:none}</style>
</noscript>




  </footer>
</body>
</html>